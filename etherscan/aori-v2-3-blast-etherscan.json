{"language":"Solidity","sources":{"contracts/AoriV2Blast.sol":{"content":"pragma solidity 0.8.24;\nimport {IERC20} from \"forge-std/interfaces/IERC20.sol\";\nimport {SafeERC20} from \"./libs/SafeERC20.sol\";\nimport {AoriV2} from \"./AoriV2.sol\";\n\ninterface IBlast {\n    // Note: the full interface for IBlast can be found below\n    function configureClaimableGas() external;\n    function configureGovernor(address governor) external;\n}\n\n/// @title AoriV2Blast\n/// @notice An implementation of the settlement contract used for the Aori V2 protocol\n/// @dev The current implementation regards a serverSigner that signs off on matching details\n///      of which the private key behind this wallet should be protected. If the private key is\n///      compromised, no funds can technically be stolen but orders will be matched in a way\n///      that is not intended i.e FIFO.\ncontract AoriV2Blast is AoriV2 {\n    /*//////////////////////////////////////////////////////////////\n                               CONSTANTS\n    //////////////////////////////////////////////////////////////*/\n\n    IBlast public constant BLAST =\n        IBlast(0x4300000000000000000000000000000000000002);\n\n    constructor(address _serverSigner) AoriV2() {\n        BLAST.configureClaimableGas();\n        BLAST.configureGovernor(_serverSigner);\n    }\n}\n"},"lib/forge-std/src/interfaces/IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2;\n\n/// @dev Interface of the ERC20 standard as defined in the EIP.\n/// @dev This includes the optional name, symbol, and decimals metadata.\ninterface IERC20 {\n    /// @dev Emitted when `value` tokens are moved from one account (`from`) to another (`to`).\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /// @dev Emitted when the allowance of a `spender` for an `owner` is set, where `value`\n    /// is the new allowance.\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /// @notice Returns the amount of tokens in existence.\n    function totalSupply() external view returns (uint256);\n\n    /// @notice Returns the amount of tokens owned by `account`.\n    function balanceOf(address account) external view returns (uint256);\n\n    /// @notice Moves `amount` tokens from the caller's account to `to`.\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /// @notice Returns the remaining number of tokens that `spender` is allowed\n    /// to spend on behalf of `owner`\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /// @notice Sets `amount` as the allowance of `spender` over the caller's tokens.\n    /// @dev Be aware of front-running risks: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /// @notice Moves `amount` tokens from `from` to `to` using the allowance mechanism.\n    /// `amount` is then deducted from the caller's allowance.\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n\n    /// @notice Returns the name of the token.\n    function name() external view returns (string memory);\n\n    /// @notice Returns the symbol of the token.\n    function symbol() external view returns (string memory);\n\n    /// @notice Returns the decimals places of the token.\n    function decimals() external view returns (uint8);\n}\n"},"contracts/libs/SafeERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.24;\nimport {IERC20} from \"forge-std/interfaces/IERC20.sol\";\nimport {Address} from \"./Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC-20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev An operation with an ERC-20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(\n        address spender,\n        uint256 currentAllowance,\n        uint256 requestedDecrease\n    );\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(\n            token,\n            abi.encodeCall(token.transferFrom, (from, to, value))\n        );\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 requestedDecrease\n    ) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(\n                    spender,\n                    currentAllowance,\n                    requestedDecrease\n                );\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        bytes memory approvalCall = abi.encodeCall(\n            token.approve,\n            (spender, value)\n        );\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(\n                token,\n                abi.encodeCall(token.approve, (spender, 0))\n            );\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(\n        IERC20 token,\n        bytes memory data\n    ) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success &&\n            (returndata.length == 0 || abi.decode(returndata, (bool))) &&\n            address(token).code.length > 0;\n    }\n}\n"},"contracts/AoriV2.sol":{"content":"pragma solidity ^0.8.24;\n\nimport {IERC20} from \"forge-std/interfaces/IERC20.sol\";\nimport {SafeERC20} from \"./libs/SafeERC20.sol\";\nimport {IFlashLoanReceiver} from \"./interfaces/IFlashLoanReceiver.sol\";\nimport {IZone} from \"./interfaces/IZone.sol\";\nimport {IClearing} from \"./interfaces/IClearing.sol\";\nimport {ClearingUtils} from \"./libs/ClearingUtils.sol\";\nimport {tuint256, tbytes32, taddress} from \"transient-goodies/TransientPrimitives.sol\";\nimport {EIP712} from \"solady/utils/EIP712.sol\";\n\ncontract AoriV2 is IClearing, EIP712 {\n    /*//////////////////////////////////////////////////////////////\n                               LIBRARIES\n    //////////////////////////////////////////////////////////////*/\n\n    using SafeERC20 for IERC20;\n\n    /*//////////////////////////////////////////////////////////////\n                                 STATE\n    //////////////////////////////////////////////////////////////*/\n\n    // @notice 2D mapping of balances. The primary index is by\n    //         owner and the secondary index is by token.\n    mapping(address => mapping(address => uint256)) private balances;\n\n    // @notice Mapping of settled orders\n    mapping(address => mapping(bytes32 => bool)) private settledOrders;\n    mapping(address => mapping(bytes32 => bool)) private cancelledOrders;\n\n    /*//////////////////////////////////////////////////////////////\n                            TRANSIENT STATE\n    //////////////////////////////////////////////////////////////*/\n\n    tuint256 private CLEARING_PHASE;\n    uint256 private constant CLEARING_PHASE_OFF = 0;\n    uint256 private constant CLEARING_PHASE_ON = 1;\n\n    mapping(bytes32 => tuint256) private CONTEXT_SETTLED_ORDERS;\n    uint256 private constant ESCROW_BIT = 1;\n    uint256 private constant RELEASE_BIT = 2;\n\n    /*//////////////////////////////////////////////////////////////\n                                 SETTLE\n    //////////////////////////////////////////////////////////////*/\n\n    // @notice Settle orders of the same zone (use a multi-call to settle multiple zones)\n    function settle(\n        SignedOrder[] calldata orders,\n        bytes calldata extraData\n    ) external payable {\n        CLEARING_PHASE.set(CLEARING_PHASE_ON);\n\n        // Check that all orders are for the same chain (this one, to prevent cross-chain replay attacks) and zone\n        address zone = address(0);\n        for (uint256 i = 0; i < orders.length; i++) {\n            require(\n                orders[i].order.chainId == block.chainid,\n                \"Order chainId does not match\"\n            );\n\n            if (zone == address(0) || zone == address(this)) {\n                zone = orders[i].order.zone;\n            } else if (\n                orders[i].order.zone != address(0) &&\n                orders[i].order.zone != address(this)\n            ) {\n                require(\n                    orders[i].order.zone == zone,\n                    \"Orders are not for the same zone\"\n                );\n            }\n\n            require(\n                !isCancelled(\n                    orders[i].order.offerer,\n                    ClearingUtils.getOrderHash(orders[i].order)\n                ),\n                \"Order has been cancelled\"\n            );\n        }\n\n        // Handle settlement\n        if (orders.length > 0) {\n            require(zone != address(0), \"Zone is not set\");\n            IZone(zone).handleSettlement(orders, extraData);\n        }\n\n        // Check that all orders have been paid\n        for (uint256 i = 0; i < orders.length; i++) {\n            bytes32 orderHash = ClearingUtils.getOrderHash(orders[i].order);\n\n            require(\n                CONTEXT_SETTLED_ORDERS[orderHash].get() & RELEASE_BIT ==\n                    RELEASE_BIT,\n                \"Order's output assets have not been paid\"\n            );\n\n            if (!hasSettled(orders[i].order.offerer, orderHash)) {\n                settledOrders[orders[i].order.offerer][orderHash] = true;\n\n                emit Settled(\n                    orderHash, // orderHash\n                    orders[i].order.zone, // zone\n                    orders[i].order.offerer, // offerer\n                    orders[i].order,\n                    orders[i].extraData\n                );\n            }\n        }\n\n        CLEARING_PHASE.set(CLEARING_PHASE_OFF);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                DEPOSIT\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Deposits tokens to the contract\n    /// @param _account The account to deposit to\n    /// @param _token The token to deposit\n    /// @param _amount The amount to deposit\n    function deposit(\n        address _account,\n        address _token,\n        uint256 _amount,\n        bytes memory _extraData\n    ) external payable {\n        // Determine the amount to transfer, being the max of the amount to send and the sender's balance\n        uint256 theirBalance = IERC20(_token).balanceOf(msg.sender);\n        uint256 amountToTransfer = _amount > theirBalance\n            ? theirBalance\n            : _amount;\n        require(amountToTransfer > 0, \"Amount to transfer is 0\");\n\n        // Transfer the amount to the contract\n        uint256 startingBalance = IERC20(_token).balanceOf(address(this));\n        IERC20(_token).safeTransferFrom(\n            msg.sender,\n            address(this),\n            amountToTransfer\n        );\n\n        // Add delta of balance to the account\n        uint256 delta = IERC20(_token).balanceOf(address(this)) -\n            startingBalance;\n        balances[_account][_token] += delta;\n        emit Deposit(msg.sender, _account, _token, delta, _extraData);\n\n        // Call handleDeposit function on the zone\n        if (msg.sender != _account && _account.code.length > 0) {\n            IZone(_account).handleDeposit(\n                msg.sender,\n                _token,\n                delta,\n                _extraData\n            );\n        }\n    }\n\n    function move(\n        address to,\n        address token,\n        uint256 amount,\n        bytes memory extraData\n    ) external {\n        // Move the max of the amount to transfer and the sender's balance\n        uint256 theirBalance = balances[msg.sender][token];\n        uint256 amountToTransfer = amount > theirBalance\n            ? theirBalance\n            : amount;\n        require(amountToTransfer > 0, \"Amount to transfer is 0\");\n\n        balances[msg.sender][token] -= amountToTransfer;\n        balances[to][token] += amountToTransfer;\n\n        emit Transfer(msg.sender, to, token, amountToTransfer, extraData);\n\n        if (msg.sender != to && to.code.length > 0) {\n            IZone(to).handleDeposit(\n                msg.sender,\n                token,\n                amountToTransfer,\n                extraData\n            );\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                WITHDRAW\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Withdraws tokens from the contract\n    /// @param _token The token to withdraw\n    /// @param _amount The amount to withdraw\n    function withdraw(\n        address _to,\n        address _token,\n        uint256 _amount,\n        bytes memory _extraData\n    ) external {\n        // They must be withdrawing less than their balance\n        uint256 theirBalance = balances[msg.sender][_token];\n        require(\n            _amount <= theirBalance,\n            \"Amount to withdraw is greater than their balance\"\n        );\n        uint256 amountToTransfer = _amount;\n\n        // Transfer the amount to the recipient\n        balances[msg.sender][_token] -= amountToTransfer;\n        IERC20(_token).safeTransfer(_to, amountToTransfer);\n        emit Withdraw(msg.sender, _to, _token, amountToTransfer, _extraData);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               FLASH LOAN\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Flash loan tokens\n    /// @param recipient The recipient\n    /// @param token The token\n    /// @param amount The amount\n    /// @param userData User data to pass to the recipient\n    /// @param receiveToken Whether to receive the token directly or fine to keep in the contract for gas efficiency\n    function flash(\n        address recipient,\n        address token,\n        uint256 amount,\n        bytes memory userData,\n        bool receiveToken\n    ) external {\n        uint256 startingBalance = IERC20(token).balanceOf(address(this));\n\n        // Flash loan\n        if (receiveToken) {\n            IERC20(token).safeTransfer(recipient, amount);\n        } else {\n            balances[recipient][token] += amount;\n        }\n\n        // call the recipient's receiveFlashLoan\n        IFlashLoanReceiver(recipient).receiveFlashLoan(\n            token,\n            amount,\n            userData,\n            receiveToken\n        );\n\n        // Repay the flash loan\n        if (receiveToken) {\n            IERC20(token).safeTransferFrom(recipient, address(this), amount);\n        } else {\n            balances[recipient][token] -= amount;\n        }\n\n        // Set invariant that the contract should have at least the starting balance\n        // or more before and after the flash loan\n        require(\n            IERC20(token).balanceOf(address(this)) >= startingBalance,\n            \"Flash loan not repaid\"\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                 CANCEL\n    //////////////////////////////////////////////////////////////*/\n\n    function cancel(SignedOrder memory signedOrder) external {\n        require(\n            msg.sender == signedOrder.order.offerer,\n            \"Only offerer can cancel\"\n        );\n\n        require(\n            ClearingUtils.verifyOrderSignature(signedOrder),\n            \"Signature does not correspond to order details\"\n        );\n\n        bytes32 orderHash = ClearingUtils.getOrderHash(signedOrder.order);\n        require(\n            !cancelledOrders[signedOrder.order.offerer][orderHash],\n            \"Order has already been cancelled\"\n        );\n        cancelledOrders[signedOrder.order.offerer][orderHash] = true;\n\n        emit Cancelled(\n            orderHash,\n            signedOrder.order.zone,\n            signedOrder.order.offerer,\n            signedOrder.order,\n            signedOrder.extraData\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ZONE ACTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function escrow(SignedOrder memory signedOrder) external {\n        require(\n            CLEARING_PHASE.get() == CLEARING_PHASE_ON,\n            \"Not in clearing phase\"\n        );\n\n        require(\n            signedOrder.order.startTime <= block.timestamp,\n            \"Order start time is in the future\"\n        );\n        require(\n            signedOrder.order.endTime >= block.timestamp,\n            \"Order end time has already passed\"\n        );\n\n        // Check zone\n        require(\n            signedOrder.order.zone == msg.sender ||\n                signedOrder.order.zone == address(0) ||\n                signedOrder.order.zone == address(this),\n            \"Order zone does not match\"\n        );\n\n        // And the chainId is the set chainId for the order such that\n        // we can protect against cross-chain signature replay attacks.\n        require(\n            signedOrder.order.chainId == block.chainid,\n            \"Order chainId does not match\"\n        );\n\n        bytes32 orderHash = ClearingUtils.getOrderHash(signedOrder.order);\n\n        // Check that the order has not been settled\n        require(\n            !hasSettled(signedOrder.order.offerer, orderHash),\n            \"Order has been settled\"\n        );\n\n        require(\n            (CONTEXT_SETTLED_ORDERS[orderHash].get() & ESCROW_BIT) !=\n                ESCROW_BIT,\n            \"Order's input assets have already been escrowed\"\n        );\n\n        if (signedOrder.order.inputAmount > 0) {\n            require(\n                ClearingUtils.verifyOrderSignature(signedOrder),\n                \"Signature does not correspond to order details\"\n            );\n        }\n\n        CONTEXT_SETTLED_ORDERS[orderHash].set(\n            CONTEXT_SETTLED_ORDERS[orderHash].get() | ESCROW_BIT\n        );\n\n        // If the input amount is 0, we don't need to escrow anything\n        if (signedOrder.order.inputAmount == 0) {\n            return;\n        }\n\n        if (\n            balances[signedOrder.order.offerer][signedOrder.order.inputToken] >\n            signedOrder.order.inputAmount\n        ) {\n            balances[signedOrder.order.offerer][\n                signedOrder.order.inputToken\n            ] -= signedOrder.order.inputAmount;\n        } else {\n            // Move assets from offerer into this contract\n            IERC20(signedOrder.order.inputToken).safeTransferFrom(\n                signedOrder.order.offerer,\n                address(this),\n                signedOrder.order.inputAmount\n            );\n        }\n\n        balances[msg.sender][signedOrder.order.inputToken] += signedOrder\n            .order\n            .inputAmount;\n    }\n\n    function release(SignedOrder memory signedOrder) external {\n        require(\n            CLEARING_PHASE.get() == CLEARING_PHASE_ON,\n            \"Not in clearing phase\"\n        );\n\n        bytes32 orderHash = ClearingUtils.getOrderHash(signedOrder.order);\n\n        require(\n            signedOrder.order.startTime <= block.timestamp,\n            \"Order start time is in the future\"\n        );\n        require(\n            signedOrder.order.endTime >= block.timestamp,\n            \"Order end time has already passed\"\n        );\n\n        // Check zone\n        require(\n            signedOrder.order.zone == msg.sender ||\n                signedOrder.order.zone == address(0) ||\n                signedOrder.order.zone == address(this),\n            \"Order zone does not match\"\n        );\n\n        // And the chainId is the set chainId for the order such that\n        // we can protect against cross-chain signature replay attacks.\n        require(\n            signedOrder.order.chainId == block.chainid,\n            \"Order chainId does not match\"\n        );\n\n        // Check that the order has not been settled\n        require(\n            !hasSettled(signedOrder.order.offerer, orderHash),\n            \"Order has been settled\"\n        );\n\n        require(\n            (CONTEXT_SETTLED_ORDERS[orderHash].get() & RELEASE_BIT) !=\n                RELEASE_BIT,\n            \"Order's output assets have already been paid\"\n        );\n\n        if (signedOrder.order.inputAmount > 0) {\n            require(\n                ClearingUtils.verifyOrderSignature(signedOrder),\n                \"Signature does not correspond to order details\"\n            );\n        }\n\n        CONTEXT_SETTLED_ORDERS[orderHash].set(\n            CONTEXT_SETTLED_ORDERS[orderHash].get() | RELEASE_BIT\n        );\n\n        // If order.outputAmount is 0, we don't need to release anything\n        if (signedOrder.order.outputAmount == 0) {\n            return;\n        }\n\n        balances[msg.sender][signedOrder.order.outputToken] -= signedOrder\n            .order\n            .outputAmount;\n\n        if (signedOrder.order.toWithdraw) {\n            IERC20(signedOrder.order.outputToken).safeTransfer(\n                signedOrder.order.recipient,\n                signedOrder.order.outputAmount\n            );\n        } else {\n            balances[signedOrder.order.recipient][\n                signedOrder.order.outputToken\n            ] += signedOrder.order.outputAmount;\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             VIEW FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function hasSettled(\n        address offerer,\n        bytes32 orderHash\n    ) public view returns (bool) {\n        return settledOrders[offerer][orderHash];\n    }\n\n    function isCancelled(\n        address offerer,\n        bytes32 orderHash\n    ) public view returns (bool) {\n        return cancelledOrders[offerer][orderHash];\n    }\n\n    function balanceOf(\n        address _account,\n        address _token\n    ) public view returns (uint256 balance) {\n        balance = balances[_account][_token];\n    }\n\n    function getOrderHash(\n        IClearing.Order memory order\n    ) public pure returns (bytes32) {\n        return ClearingUtils.getOrderHash(order);\n    }\n\n    function getSignatureMessage(\n        IClearing.SignedOrder memory signedOrder\n    ) public pure returns (bytes32) {\n        return ClearingUtils.getSignatureMessage(signedOrder);\n    }\n\n    function verifyOrderSignature(\n        IClearing.SignedOrder memory signedOrder\n    ) public view returns (bool) {\n        return ClearingUtils.verifyOrderSignature(signedOrder);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                EIP-712\n    //////////////////////////////////////////////////////////////*/\n\n    function _domainNameAndVersion()\n        internal\n        view\n        override\n        returns (string memory name, string memory version)\n    {\n        name = \"Aori\";\n        version = \"v2.0\";\n    }\n}\n"},"contracts/libs/Address.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(\n        address target,\n        bytes memory data\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(\n            data\n        );\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata\n    ) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n"},"contracts/interfaces/IFlashLoanReceiver.sol":{"content":"pragma solidity 0.8.24;\n\ninterface IFlashLoanReceiver {\n    function receiveFlashLoan(\n        address token,\n        uint256 amount,\n        bytes calldata data,\n        bool receiveToken\n    ) external;\n}\n"},"contracts/interfaces/IZone.sol":{"content":"pragma solidity 0.8.24;\n\nimport {IClearing} from \"./IClearing.sol\";\n\ninterface IZone {\n    // @dev This function can be used to choose who can access an off-chain channel\n    // function verifyOwnership(\n    //     bytes32 data,\n    //     bytes memory signature\n    // ) external view returns (bool);\n\n    function name() external view returns (string memory);\n\n    function handleSettlement(\n        IClearing.SignedOrder[] memory orders,\n        bytes memory extraData\n    ) external;\n\n    function handleDeposit(\n        address from,\n        address token,\n        uint256 amount,\n        bytes memory extraData\n    ) external;\n}\n"},"contracts/interfaces/IClearing.sol":{"content":"pragma solidity 0.8.24;\n\ninterface IClearing {\n    /*//////////////////////////////////////////////////////////////\n                                STRUCTS\n    //////////////////////////////////////////////////////////////*/\n\n    struct Order {\n        address offerer;\n        address inputToken;\n        uint256 inputAmount;\n        address outputToken;\n        uint256 outputAmount;\n        address recipient;\n        // =====\n        address zone;\n        uint160 chainId;\n        uint32 startTime;\n        uint32 endTime;\n        // =====\n        bool toWithdraw;\n    }\n\n    struct SignedOrder {\n        Order order;\n        bytes extraData;\n        bytes signature;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Deposit(\n        address indexed from,\n        address indexed account,\n        address indexed token,\n        uint256 amount,\n        bytes extraData\n    );\n\n    event Withdraw(\n        address indexed from,\n        address indexed account,\n        address indexed token,\n        uint256 amount,\n        bytes extraData\n    );\n\n    event Transfer(\n        address indexed from,\n        address indexed account,\n        address indexed token,\n        uint256 amount,\n        bytes extraData\n    );\n\n    event Settled(\n        bytes32 indexed orderHash,\n        address indexed zone,\n        address indexed offerer,\n        Order order,\n        bytes extraData\n    );\n\n    event Cancelled(\n        bytes32 indexed orderHash,\n        address indexed zone,\n        address indexed offerer,\n        Order order,\n        bytes extraData\n    );\n\n    /*//////////////////////////////////////////////////////////////\n                                 FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function settle(\n        SignedOrder[] memory orders,\n        bytes memory extraData\n    ) external payable;\n\n    function deposit(\n        address account,\n        address token,\n        uint256 amount,\n        bytes memory extraData\n    ) external payable;\n\n    function move(\n        address to,\n        address token,\n        uint256 amount,\n        bytes memory extraData\n    ) external;\n\n    function withdraw(\n        address to,\n        address token,\n        uint256 amount,\n        bytes memory extraData\n    ) external;\n\n    function flash(\n        address recipient,\n        address token,\n        uint256 amount,\n        bytes memory userData,\n        bool receiveToken\n    ) external;\n\n    function cancel(SignedOrder memory signedOrder) external;\n\n    function escrow(SignedOrder memory signedOrder) external;\n\n    function release(SignedOrder memory signedOrder) external;\n\n    function balanceOf(\n        address account,\n        address token\n    ) external view returns (uint256);\n\n    function hasSettled(\n        address offerer,\n        bytes32 orderHash\n    ) external view returns (bool);\n}\n"},"contracts/libs/ClearingUtils.sol":{"content":"pragma solidity ^0.8.24;\n\nimport {IClearing} from \"../interfaces/IClearing.sol\";\nimport {SignatureChecker} from \"./SignatureChecker.sol\";\n\nlibrary ClearingUtils {\n    /*//////////////////////////////////////////////////////////////\n                               LIBRARIES\n    //////////////////////////////////////////////////////////////*/\n\n    using SignatureChecker for address;\n\n    /*//////////////////////////////////////////////////////////////\n                            ORDER VALIDATION\n    //////////////////////////////////////////////////////////////*/\n\n    function getOrderHash(\n        IClearing.Order memory order\n    ) internal pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(\n                    order.offerer,\n                    order.inputToken,\n                    order.inputAmount,\n                    order.outputToken,\n                    order.outputAmount,\n                    order.recipient,\n                    // =====\n                    order.zone,\n                    order.chainId,\n                    order.startTime,\n                    order.endTime,\n                    // =====\n                    order.toWithdraw\n                )\n            );\n    }\n\n    function getSignatureMessage(\n        IClearing.SignedOrder memory signedOrder\n    ) internal pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(\n                    getOrderHash(signedOrder.order),\n                    signedOrder.extraData\n                )\n            );\n    }\n\n    function verifyOrderSignature(\n        IClearing.SignedOrder memory signedOrder\n    ) internal view returns (bool) {\n        (uint8 v, bytes32 r, bytes32 s) = signatureIntoComponents(\n            signedOrder.signature\n        );\n\n        // Allow for signing by either standard compact-hashing (getSignatureMessage) or EIP-712 (TODO:)\n        bytes32 quickSignatureMessage = getSignatureMessage(signedOrder);\n\n        return\n            signedOrder.order.offerer.isValidSignatureNow(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19Ethereum Signed Message:\\n32\",\n                        quickSignatureMessage\n                    )\n                ),\n                abi.encodePacked(r, s, v)\n            ) ||\n            // TEMP: for orders with no extraData, allow for signing by orderHash\n            (signedOrder.extraData.length == 0 &&\n                signedOrder.order.offerer.isValidSignatureNow(\n                    keccak256(\n                        abi.encodePacked(\n                            \"\\x19Ethereum Signed Message:\\n32\",\n                            getOrderHash(signedOrder.order)\n                        )\n                    ),\n                    abi.encodePacked(r, s, v)\n                ));\n    }\n\n    function signatureIntoComponents(\n        bytes memory signature\n    ) internal pure returns (uint8 v, bytes32 r, bytes32 s) {\n        assembly {\n            r := mload(add(signature, 0x20))\n            s := mload(add(signature, 0x40))\n            v := byte(0, mload(add(signature, 0x60)))\n        }\n\n        if (v < 27) {\n            v += 27;\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          SEQUENCE VALIDATION\n    //////////////////////////////////////////////////////////////*/\n\n    function getSequenceMessage(\n        IClearing.SignedOrder[] memory signedOrders,\n        bytes memory extraData\n    ) internal pure returns (bytes32) {\n        bytes32[] memory orderHashes = new bytes32[](signedOrders.length);\n\n        for (uint i; i < signedOrders.length; i++) {\n            orderHashes[i] = getSignatureMessage(signedOrders[i]);\n        }\n\n        return keccak256(abi.encodePacked(orderHashes, extraData));\n    }\n\n    function verifySequenceSignature(\n        IClearing.SignedOrder[] memory signedOrders,\n        bytes memory extraData,\n        bytes memory signature,\n        address expectedSigner\n    ) internal view returns (bool) {\n        (uint8 v, bytes32 r, bytes32 s) = signatureIntoComponents(signature);\n        bytes32 quickSignatureMessage = getSequenceMessage(\n            signedOrders,\n            extraData\n        );\n\n        return\n            expectedSigner.isValidSignatureNow(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19Ethereum Signed Message:\\n32\",\n                        quickSignatureMessage\n                    )\n                ),\n                abi.encodePacked(r, s, v)\n            );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                EIP-712\n    //////////////////////////////////////////////////////////////*/\n\n    function _eip712_ORDER_TYPE_HASH() internal pure returns (bytes32) {\n        return\n            keccak256(\n                \"Order(address offerer,address inputToken,uint256 inputAmount,address outputToken,uint256 outputAmount,address recipient,uint256 zone,uint160 chainId,uint32 startTime,uint32 endTime,bool toWithdraw)\"\n            );\n    }\n\n    function _eip712_hashOrder(\n        IClearing.Order memory order\n    ) internal pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    _eip712_ORDER_TYPE_HASH(),\n                    order.offerer,\n                    order.inputToken,\n                    order.inputAmount,\n                    order.outputToken,\n                    order.outputAmount,\n                    order.recipient,\n                    order.zone,\n                    order.chainId,\n                    order.startTime,\n                    order.endTime,\n                    order.toWithdraw\n                )\n            );\n    }\n\n    function _eip712_SIGNEDORDER_TYPE_HASH() internal pure returns (bytes32) {\n        return keccak256(\"SignedOrder(Order order,bytes extraData)\");\n    }\n\n    function _eip712_hashSignedOrder(\n        IClearing.Order memory order,\n        bytes memory extraData\n    ) internal pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(_eip712_SIGNEDORDER_TYPE_HASH(), order, extraData)\n            );\n    }\n\n    // TODO: add in domain fetch and digest creation\n}\n"},"lib/transient-goodies/src/TransientPrimitives.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\n/// @author philogy <https://github.com/philogy>\n\nstruct tuint256 {\n    uint256 __placeholder;\n}\n\nstruct tint256 {\n    uint256 __placeholder;\n}\n\nstruct tbytes32 {\n    uint256 __placeholder;\n}\n\nstruct taddress {\n    uint256 __placeholder;\n}\n\nusing TransientPrimitivesLib for tuint256 global;\nusing TransientPrimitivesLib for tint256 global;\nusing TransientPrimitivesLib for tbytes32 global;\nusing TransientPrimitivesLib for taddress global;\n\nlibrary TransientPrimitivesLib {\n    error ArithmeticOverflowUnderflow();\n\n    function get(tuint256 storage ptr) internal view returns (uint256 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(ptr.slot)\n        }\n    }\n\n    function get(tint256 storage ptr) internal view returns (int256 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(ptr.slot)\n        }\n    }\n\n    function get(tbytes32 storage ptr) internal view returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(ptr.slot)\n        }\n    }\n\n    function get(taddress storage ptr) internal view returns (address value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(ptr.slot)\n        }\n    }\n\n    function set(tuint256 storage ptr, uint256 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(ptr.slot, value)\n        }\n    }\n\n    function inc(tuint256 storage ptr, uint256 change) internal returns (uint256 newValue) {\n        ptr.set(newValue = ptr.get() + change);\n    }\n\n    function dec(tuint256 storage ptr, uint256 change) internal returns (uint256 newValue) {\n        ptr.set(newValue = ptr.get() - change);\n    }\n\n    function inc(tuint256 storage ptr, int256 change) internal returns (uint256 newValue) {\n        uint256 currentValue = ptr.get();\n        assembly (\"memory-safe\") {\n            newValue := add(currentValue, change)\n            if iszero(eq(lt(newValue, currentValue), slt(change, 0))) {\n                mstore(0x00, 0xc9654ed4 /* ArithmeticOverflowUnderflow() */ )\n                revert(0x1c, 0x04)\n            }\n        }\n        ptr.set(newValue);\n    }\n\n    function dec(tuint256 storage ptr, int256 change) internal returns (uint256 newValue) {\n        uint256 currentValue = ptr.get();\n        assembly (\"memory-safe\") {\n            newValue := sub(currentValue, change)\n            if iszero(eq(lt(newValue, currentValue), sgt(change, 0))) {\n                mstore(0x00, 0xc9654ed4 /* ArithmeticOverflowUnderflow() */ )\n                revert(0x1c, 0x04)\n            }\n        }\n        ptr.set(newValue);\n    }\n\n    function set(tint256 storage ptr, int256 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(ptr.slot, value)\n        }\n    }\n\n    function inc(tint256 storage ptr, int256 change) internal returns (int256 newValue) {\n        ptr.set(newValue = ptr.get() + change);\n    }\n\n    function dec(tint256 storage ptr, int256 change) internal returns (int256 newValue) {\n        ptr.set(newValue = ptr.get() - change);\n    }\n\n    function set(tbytes32 storage ptr, bytes32 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(ptr.slot, value)\n        }\n    }\n\n    function set(taddress storage ptr, address value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(ptr.slot, value)\n        }\n    }\n}\n"},"lib/solady/src/utils/EIP712.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Contract for EIP-712 typed structured data hashing and signing.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/EIP712.sol)\n/// @author Modified from Solbase (https://github.com/Sol-DAO/solbase/blob/main/src/utils/EIP712.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/EIP712.sol)\n///\n/// @dev Note, this implementation:\n/// - Uses `address(this)` for the `verifyingContract` field.\n/// - Does NOT use the optional EIP-712 salt.\n/// - Does NOT use any EIP-712 extensions.\n/// This is for simplicity and to save gas.\n/// If you need to customize, please fork / modify accordingly.\nabstract contract EIP712 {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                  CONSTANTS AND IMMUTABLES                  */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev `keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\")`.\n    bytes32 internal constant _DOMAIN_TYPEHASH =\n        0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\n\n    uint256 private immutable _cachedThis;\n    uint256 private immutable _cachedChainId;\n    bytes32 private immutable _cachedNameHash;\n    bytes32 private immutable _cachedVersionHash;\n    bytes32 private immutable _cachedDomainSeparator;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                        CONSTRUCTOR                         */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Cache the hashes for cheaper runtime gas costs.\n    /// In the case of upgradeable contracts (i.e. proxies),\n    /// or if the chain id changes due to a hard fork,\n    /// the domain separator will be seamlessly calculated on-the-fly.\n    constructor() {\n        _cachedThis = uint256(uint160(address(this)));\n        _cachedChainId = block.chainid;\n\n        string memory name;\n        string memory version;\n        if (!_domainNameAndVersionMayChange()) (name, version) = _domainNameAndVersion();\n        bytes32 nameHash = _domainNameAndVersionMayChange() ? bytes32(0) : keccak256(bytes(name));\n        bytes32 versionHash =\n            _domainNameAndVersionMayChange() ? bytes32(0) : keccak256(bytes(version));\n        _cachedNameHash = nameHash;\n        _cachedVersionHash = versionHash;\n\n        bytes32 separator;\n        if (!_domainNameAndVersionMayChange()) {\n            /// @solidity memory-safe-assembly\n            assembly {\n                let m := mload(0x40) // Load the free memory pointer.\n                mstore(m, _DOMAIN_TYPEHASH)\n                mstore(add(m, 0x20), nameHash)\n                mstore(add(m, 0x40), versionHash)\n                mstore(add(m, 0x60), chainid())\n                mstore(add(m, 0x80), address())\n                separator := keccak256(m, 0xa0)\n            }\n        }\n        _cachedDomainSeparator = separator;\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   FUNCTIONS TO OVERRIDE                    */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Please override this function to return the domain name and version.\n    /// ```\n    ///     function _domainNameAndVersion()\n    ///         internal\n    ///         pure\n    ///         virtual\n    ///         returns (string memory name, string memory version)\n    ///     {\n    ///         name = \"Solady\";\n    ///         version = \"1\";\n    ///     }\n    /// ```\n    ///\n    /// Note: If the returned result may change after the contract has been deployed,\n    /// you must override `_domainNameAndVersionMayChange()` to return true.\n    function _domainNameAndVersion()\n        internal\n        view\n        virtual\n        returns (string memory name, string memory version);\n\n    /// @dev Returns if `_domainNameAndVersion()` may change\n    /// after the contract has been deployed (i.e. after the constructor).\n    /// Default: false.\n    function _domainNameAndVersionMayChange() internal pure virtual returns (bool result) {}\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                     HASHING OPERATIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the EIP-712 domain separator.\n    function _domainSeparator() internal view virtual returns (bytes32 separator) {\n        if (_domainNameAndVersionMayChange()) {\n            separator = _buildDomainSeparator();\n        } else {\n            separator = _cachedDomainSeparator;\n            if (_cachedDomainSeparatorInvalidated()) separator = _buildDomainSeparator();\n        }\n    }\n\n    /// @dev Returns the hash of the fully encoded EIP-712 message for this domain,\n    /// given `structHash`, as defined in\n    /// https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct.\n    ///\n    /// The hash can be used together with {ECDSA-recover} to obtain the signer of a message:\n    /// ```\n    ///     bytes32 digest = _hashTypedData(keccak256(abi.encode(\n    ///         keccak256(\"Mail(address to,string contents)\"),\n    ///         mailTo,\n    ///         keccak256(bytes(mailContents))\n    ///     )));\n    ///     address signer = ECDSA.recover(digest, signature);\n    /// ```\n    function _hashTypedData(bytes32 structHash) internal view virtual returns (bytes32 digest) {\n        // We will use `digest` to store the domain separator to save a bit of gas.\n        if (_domainNameAndVersionMayChange()) {\n            digest = _buildDomainSeparator();\n        } else {\n            digest = _cachedDomainSeparator;\n            if (_cachedDomainSeparatorInvalidated()) digest = _buildDomainSeparator();\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the digest.\n            mstore(0x00, 0x1901000000000000) // Store \"\\x19\\x01\".\n            mstore(0x1a, digest) // Store the domain separator.\n            mstore(0x3a, structHash) // Store the struct hash.\n            digest := keccak256(0x18, 0x42)\n            // Restore the part of the free memory slot that was overwritten.\n            mstore(0x3a, 0)\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                    EIP-5267 OPERATIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev See: https://eips.ethereum.org/EIPS/eip-5267\n    function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        fields = hex\"0f\"; // `0b01111`.\n        (name, version) = _domainNameAndVersion();\n        chainId = block.chainid;\n        verifyingContract = address(this);\n        salt = salt; // `bytes32(0)`.\n        extensions = extensions; // `new uint256[](0)`.\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      PRIVATE HELPERS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the EIP-712 domain separator.\n    function _buildDomainSeparator() private view returns (bytes32 separator) {\n        // We will use `separator` to store the name hash to save a bit of gas.\n        bytes32 versionHash;\n        if (_domainNameAndVersionMayChange()) {\n            (string memory name, string memory version) = _domainNameAndVersion();\n            separator = keccak256(bytes(name));\n            versionHash = keccak256(bytes(version));\n        } else {\n            separator = _cachedNameHash;\n            versionHash = _cachedVersionHash;\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Load the free memory pointer.\n            mstore(m, _DOMAIN_TYPEHASH)\n            mstore(add(m, 0x20), separator) // Name hash.\n            mstore(add(m, 0x40), versionHash)\n            mstore(add(m, 0x60), chainid())\n            mstore(add(m, 0x80), address())\n            separator := keccak256(m, 0xa0)\n        }\n    }\n\n    /// @dev Returns if the cached domain separator has been invalidated.\n    function _cachedDomainSeparatorInvalidated() private view returns (bool result) {\n        uint256 cachedChainId = _cachedChainId;\n        uint256 cachedThis = _cachedThis;\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := iszero(and(eq(chainid(), cachedChainId), eq(address(), cachedThis)))\n        }\n    }\n}\n"},"contracts/libs/SignatureChecker.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/SignatureChecker.sol)\n\npragma solidity 0.8.24;\n\nimport {ECDSA} from \"./ECDSA.sol\";\nimport {IERC1271} from \"../interfaces/IERC1271.sol\";\n\n/**\n * @dev Signature verification helper that can be used instead of `ECDSA.recover` to seamlessly support both ECDSA\n * signatures from externally owned accounts (EOAs) as well as ERC-1271 signatures from smart contract wallets like\n * Argent and Safe Wallet (previously Gnosis Safe).\n */\nlibrary SignatureChecker {\n    /**\n     * @dev Checks if a signature is valid for a given signer and data hash. If the signer is a smart contract, the\n     * signature is validated against that smart contract using ERC-1271, otherwise it's validated using `ECDSA.recover`.\n     *\n     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus\n     * change through time. It could return true at block N and false at block N+1 (or the opposite).\n     */\n    function isValidSignatureNow(\n        address signer,\n        bytes32 hash,\n        bytes memory signature\n    ) internal view returns (bool) {\n        (address recovered, ECDSA.RecoverError error, ) = ECDSA.tryRecover(\n            hash,\n            signature\n        );\n        return\n            (error == ECDSA.RecoverError.NoError && recovered == signer) ||\n            isValidERC1271SignatureNow(signer, hash, signature);\n    }\n\n    /**\n     * @dev Checks if a signature is valid for a given signer and data hash. The signature is validated\n     * against the signer smart contract using ERC-1271.\n     *\n     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus\n     * change through time. It could return true at block N and false at block N+1 (or the opposite).\n     */\n    function isValidERC1271SignatureNow(\n        address signer,\n        bytes32 hash,\n        bytes memory signature\n    ) internal view returns (bool) {\n        (bool success, bytes memory result) = signer.staticcall(\n            abi.encodeCall(IERC1271.isValidSignature, (hash, signature))\n        );\n        return (success &&\n            result.length >= 32 &&\n            abi.decode(result, (bytes32)) ==\n            bytes32(IERC1271.isValidSignature.selector));\n    }\n}\n"},"contracts/libs/ECDSA.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity 0.8.24;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n\n    /**\n     * @dev The signature derives the `address(0)`.\n     */\n    error ECDSAInvalidSignature();\n\n    /**\n     * @dev The signature has an invalid length.\n     */\n    error ECDSAInvalidSignatureLength(uint256 length);\n\n    /**\n     * @dev The signature has an S value that is in the upper half order.\n     */\n    error ECDSAInvalidSignatureS(bytes32 s);\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with `signature` or an error. This will not\n     * return address(0) without also returning an error description. Errors are documented using an enum (error type)\n     * and a bytes32 providing additional information about the error.\n     *\n     * If no error is returned, then the address can be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes memory signature\n    ) internal pure returns (address, RecoverError, bytes32) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (\n                address(0),\n                RecoverError.InvalidSignatureLength,\n                bytes32(signature.length)\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     */\n    function recover(\n        bytes32 hash,\n        bytes memory signature\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(\n            hash,\n            signature\n        );\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[ERC-2098 short signatures]\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError, bytes32) {\n        unchecked {\n            bytes32 s = vs &\n                bytes32(\n                    0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n                );\n            // We do not check for an overflow here since the shift operation results in 0 or 1.\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(\n            hash,\n            r,\n            vs\n        );\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError, bytes32) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (\n            uint256(s) >\n            0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0\n        ) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(\n            hash,\n            v,\n            r,\n            s\n        );\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Optionally reverts with the corresponding custom error according to the `error` argument provided.\n     */\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}\n"},"contracts/interfaces/IERC1271.sol":{"content":"pragma solidity 0.8.24;\n\ninterface IERC1271 {\n    // bytes4(keccak256(\"isValidSignature(bytes32,bytes)\")\n    // bytes4 constant internal MAGICVALUE = 0x1626ba7e;\n\n    /**\n     * @dev Should return whether the signature provided is valid for the provided hash\n     * @param _hash      Hash of the data to be signed\n     * @param _signature Signature byte array associated with _hash\n     *\n     * MUST return the bytes4 magic value 0x1626ba7e when function passes.\n     * MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc > 0.5)\n     * MUST allow external calls\n     */\n    function isValidSignature(\n        bytes32 _hash,\n        bytes memory _signature\n    ) external view returns (bytes4 magicValue);\n}\n"}},"settings":{"remappings":["ds-test/=lib/ds-test/src/","solmate/=lib/solmate/src/","forge-std/=lib/forge-std/src/","transient-goodies/=lib/transient-goodies/src/","solady/=lib/solady/src/","create3-factory/=lib/create3-factory/"],"optimizer":{"enabled":true,"runs":1000000},"metadata":{"useLiteralContent":false,"bytecodeHash":"ipfs","appendCBOR":true},"outputSelection":{"*":{"*":["abi","evm.bytecode","evm.deployedBytecode","evm.methodIdentifiers","metadata"]}},"evmVersion":"cancun","viaIR":true,"libraries":{}}}
