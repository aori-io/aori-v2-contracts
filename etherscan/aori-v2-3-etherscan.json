{"language":"Solidity","sources":{"src/AoriV2.sol":{"content":"pragma solidity 0.8.17;\nimport {IERC20} from \"forge-std/interfaces/IERC20.sol\";\nimport {SafeERC20} from \"./libs/SafeERC20.sol\";\nimport {BitMaps} from \"./libs/BitMaps.sol\";\nimport {IAoriV2} from \"./interfaces/IAoriV2.sol\";\nimport {IAoriHook} from \"./interfaces/IAoriHook.sol\";\nimport {IERC1271} from \"./interfaces/IERC1271.sol\";\nimport {IERC165} from \"./interfaces/IERC165.sol\";\nimport {IFlashLoanReceiver} from \"./interfaces/IFlashLoanReceiver.sol\";\nimport {SignatureChecker} from \"./libs/SignatureChecker.sol\";\n\n/// @title AoriV2\n/// @notice An implementation of the settlement contract used for the Aori V2 protocol\n/// @dev The current implementation regards a serverSigner that signs off on matching details\n///      of which the private key behind this wallet should be protected. If the private key is\n///      compromised, no funds can technically be stolen but orders will be matched in a way\n///      that is not intended i.e FIFO.\ncontract AoriV2 is IAoriV2 {\n    /*//////////////////////////////////////////////////////////////\n                               LIBRARIES\n    //////////////////////////////////////////////////////////////*/\n\n    using BitMaps for BitMaps.BitMap;\n    using SafeERC20 for IERC20;\n    using SignatureChecker for address;\n\n    /*//////////////////////////////////////////////////////////////\n                                 STATE\n    //////////////////////////////////////////////////////////////*/\n\n    // @notice Orders are stored using buckets of bitmaps to allow\n    //         for potential gas optimisations by a bucket's bitmap\n    //         having been written to previously. Programmatic\n    //         users can also attempt to mine for specific order\n    //         hashes to hit a used bucket.\n    BitMaps.BitMap private orderStatus;\n\n    // @notice 2D mapping of balances. The primary index is by\n    //         owner and the secondary index is by token.\n    mapping(address => mapping(address => uint256)) private balances;\n\n    // @notice Server signer wallet used to verify matching for\n    //         this contract. Again, the key should be protected.\n    //         In the case that a key is compromised, no funds\n    //         can be stolen but orders may be matched in an\n    //         unfair way. A new contract would need to be\n    //         deployed with a new deployer.\n    address public immutable serverSigner;\n\n    // @notice Taker fee recipient and fee in bips\n    address private takerFeeRecipient;\n    uint256 private takerFeeInBips;\n    uint256 private constant TAKER_FEE_DENOMINATOR = 10_000;\n\n    // @notice Reentrancy guard\n    bool private locked;\n\n    /*//////////////////////////////////////////////////////////////\n                              CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(address _serverSigner) {\n        require(\n            _serverSigner != address(0),\n            \"Server signer cannot be zero address\"\n        );\n        serverSigner = _serverSigner;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                 SETTLE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Main bulk of the logic for validating and settling orders\n    /// @param matching   The matching details of the orders to settle\n    /// @param serverSignature  The signature of the server signer\n    /// @dev Server signer signature must be signed with the private key of the server signer\n    function settleOrders(\n        MatchingDetails calldata matching,\n        bytes calldata serverSignature,\n        bytes calldata hookData\n    ) external payable {\n        /*//////////////////////////////////////////////////////////////\n                           SPECIFIC ORDER VALIDATION\n        //////////////////////////////////////////////////////////////*/\n\n        // Check start and end times of orders\n        require(\n            matching.makerOrder.startTime <= block.timestamp,\n            \"Maker order start time is in the future\"\n        );\n        require(\n            matching.takerOrder.startTime <= block.timestamp,\n            \"Taker order start time is in the future\"\n        );\n        require(\n            matching.makerOrder.endTime >= block.timestamp,\n            \"Maker order end time has already passed\"\n        );\n        require(\n            matching.takerOrder.endTime >= block.timestamp,\n            \"Taker order end time has already passed\"\n        );\n\n        // And the chainId is the set chainId for the order such that\n        // we can protect against cross-chain signature replay attacks.\n        require(\n            matching.makerOrder.chainId == matching.takerOrder.chainId,\n            \"Maker order's chainid does not match taker order's chainid\"\n        );\n\n        require(\n            matching.makerOrder.chainId == block.chainid,\n            \"Order's chainid does not match current chainid\"\n        );\n\n        // Check zone\n        require(\n            matching.makerOrder.zone == matching.takerOrder.zone,\n            \"Maker order's zone does not match taker order's zone\"\n        );\n        require(\n            matching.makerOrder.zone == address(this),\n            \"Zone does not match this contract\"\n        );\n\n        /*//////////////////////////////////////////////////////////////\n                              SIGNATURE VALIDATION\n        //////////////////////////////////////////////////////////////*/\n\n        // Compute order hashes of both orders\n        bytes32 makerHash = getOrderHash(matching.makerOrder);\n        bytes32 takerHash = getOrderHash(matching.takerOrder);\n\n        // Check maker signature\n        if (matching.makerOrder.inputAmount > 0) {\n            (\n                uint8 makerV,\n                bytes32 makerR,\n                bytes32 makerS\n            ) = signatureIntoComponents(matching.makerSignature);\n            require(\n                matching.makerOrder.offerer.isValidSignatureNow(\n                    keccak256(\n                        abi.encodePacked(\n                            \"\\x19Ethereum Signed Message:\\n32\",\n                            makerHash\n                        )\n                    ),\n                    abi.encodePacked(makerR, makerS, makerV)\n                ),\n                \"Maker signature does not correspond to order details\"\n            );\n        }\n\n        // Check taker signature\n        if (matching.takerOrder.inputAmount > 0) {\n            (\n                uint8 takerV,\n                bytes32 takerR,\n                bytes32 takerS\n            ) = signatureIntoComponents(matching.takerSignature);\n            require(\n                matching.takerOrder.offerer.isValidSignatureNow(\n                    keccak256(\n                        abi.encodePacked(\n                            \"\\x19Ethereum Signed Message:\\n32\",\n                            takerHash\n                        )\n                    ),\n                    abi.encodePacked(takerR, takerS, takerV)\n                ),\n                \"Taker signature does not correspond to order details\"\n            );\n        }\n\n        /*//////////////////////////////////////////////////////////////\n                              MATCHING VALIDATION\n        //////////////////////////////////////////////////////////////*/\n\n        // Check that tokens are for each other\n        require(\n            matching.makerOrder.inputToken == matching.takerOrder.outputToken,\n            \"Maker order input token is not equal to taker order output token\"\n        );\n        require(\n            matching.makerOrder.outputToken == matching.takerOrder.inputToken,\n            \"Maker order output token is not equal to taker order input token\"\n        );\n\n        // Check input/output amounts\n        require(\n            matching.takerOrder.outputAmount <= matching.makerOrder.inputAmount,\n            \"Taker order output amount is more than maker order input amount\"\n        );\n        require(\n            withFee(matching.makerOrder.outputAmount, takerFeeInBips) <=\n                matching.takerOrder.inputAmount,\n            \"Maker order output amount is more than taker order input amount\"\n        );\n\n        // Check order statuses and make sure that they haven't been settled\n        require(\n            !BitMaps.get(orderStatus, uint256(makerHash)),\n            \"Maker order has been settled\"\n        );\n        require(\n            !BitMaps.get(orderStatus, uint256(takerHash)),\n            \"Taker order has been settled\"\n        );\n\n        (\n            uint8 serverV,\n            bytes32 serverR,\n            bytes32 serverS\n        ) = signatureIntoComponents(serverSignature);\n\n        // Ensure that the server has signed off on these matching details\n        require(\n            serverSigner.isValidSignatureNow(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19Ethereum Signed Message:\\n32\",\n                        getMatchingHash(matching)\n                    )\n                ),\n                abi.encodePacked(serverR, serverS, serverV)\n            ),\n            \"Server signature does not correspond to order details\"\n        );\n\n        // These two lines alone cost 40k gas due to storage in the worst case :sad:\n        // This itself is a form of non-reentrancy due to the order status checks above.\n        BitMaps.set(orderStatus, uint256(makerHash));\n        BitMaps.set(orderStatus, uint256(takerHash));\n\n        /*//////////////////////////////////////////////////////////////\n                             SETTLE: TAKER-TO-MAKER\n        //////////////////////////////////////////////////////////////*/\n\n        // (Taker ==> Maker) processing\n        // Either subtract from in-contract balance or transfer from taker's wallet\n        if (\n            balances[matching.takerOrder.offerer][\n                matching.takerOrder.inputToken\n            ] >= matching.takerOrder.inputAmount\n        ) {\n            balances[matching.takerOrder.offerer][\n                matching.takerOrder.inputToken\n            ] -= matching.takerOrder.inputAmount;\n        } else {\n            // Transfer from their own wallet - move taker order assets into here\n            IERC20(matching.takerOrder.inputToken).safeTransferFrom(\n                matching.takerOrder.offerer,\n                address(this),\n                matching.takerOrder.inputAmount\n            );\n        }\n\n        // If maker would like their output tokens withdrawn to them, they can do so.\n        // Enabling the maker to receive the tokens first before we process their side\n        // for them to have native flash-loan-like capabilities.\n        if (!matching.makerOrder.toWithdraw) {\n            // Add balance\n            balances[matching.makerOrder.recipient][\n                matching.makerOrder.outputToken\n            ] += matching.makerOrder.outputAmount;\n        } else {\n            IERC20(matching.makerOrder.outputToken).safeTransfer(\n                matching.makerOrder.recipient,\n                matching.makerOrder.outputAmount\n            );\n        }\n\n        /*//////////////////////////////////////////////////////////////\n                             SETTLE: MAKER-TO-TAKER\n        //////////////////////////////////////////////////////////////*/\n\n        // (Maker ==> Taker) processing\n        // Before-Aori-Trade Hook\n        if (\n            matching.makerOrder.offerer.code.length > 0 &&\n            IERC165(matching.makerOrder.offerer).supportsInterface(\n                IAoriHook.beforeAoriTrade.selector\n            )\n        ) {\n            bool success = IAoriHook(matching.makerOrder.offerer)\n                .beforeAoriTrade(matching, hookData);\n            require(success, \"BeforeAoriTrade hook failed\");\n        }\n\n        // Subtract from maker's balance\n        if (\n            balances[matching.makerOrder.offerer][\n                matching.makerOrder.inputToken\n            ] >= matching.makerOrder.inputAmount\n        ) {\n            balances[matching.makerOrder.offerer][\n                matching.makerOrder.inputToken\n            ] -= matching.makerOrder.inputAmount;\n        } else {\n            IERC20(matching.makerOrder.inputToken).safeTransferFrom(\n                matching.makerOrder.offerer,\n                address(this),\n                matching.makerOrder.inputAmount\n            );\n        }\n\n        // Taker receive tokens\n        if (!matching.takerOrder.toWithdraw) {\n            balances[matching.takerOrder.recipient][\n                matching.takerOrder.outputToken\n            ] += matching.takerOrder.outputAmount;\n        } else {\n            IERC20(matching.takerOrder.outputToken).safeTransfer(\n                matching.takerOrder.recipient,\n                matching.takerOrder.outputAmount\n            );\n        }\n\n        /*//////////////////////////////////////////////////////////////\n                            SETTLE: FEE PROCESSING\n        //////////////////////////////////////////////////////////////*/\n\n        // First, pay taker fee\n        if (takerFeeInBips > 0) {\n            balances[takerFeeRecipient][matching.makerOrder.outputToken] +=\n                withFee(matching.makerOrder.outputAmount, takerFeeInBips) -\n                matching.makerOrder.outputAmount;\n        }\n\n        // Fee processing\n        // The fee recipient keeps any excess\n        if (\n            matching.makerOrder.inputAmount > matching.takerOrder.outputAmount\n        ) {\n            balances[matching.feeRecipient][matching.takerOrder.outputToken] +=\n                matching.makerOrder.inputAmount -\n                matching.takerOrder.outputAmount;\n        }\n\n        if (\n            matching.takerOrder.inputAmount >\n            withFee(matching.makerOrder.outputAmount, takerFeeInBips)\n        ) {\n            balances[matching.feeRecipient][matching.makerOrder.outputToken] +=\n                matching.takerOrder.inputAmount -\n                withFee(matching.makerOrder.outputAmount, takerFeeInBips);\n        }\n\n        /*//////////////////////////////////////////////////////////////\n                             POST-TRADE PROCESSING\n        //////////////////////////////////////////////////////////////*/\n\n        // Emit\n        emit FeeReceived(\n            matching.feeRecipient,\n            matching.feeTag,\n            matching.makerOrder.inputToken,\n            matching.makerOrder.inputAmount - matching.takerOrder.outputAmount,\n            matching.makerOrder.outputToken,\n            matching.takerOrder.inputAmount -\n                withFee(matching.makerOrder.outputAmount, takerFeeInBips)\n        );\n\n        // After-Aori-Trade Hook\n        if (\n            matching.makerOrder.offerer.code.length > 0 &&\n            IERC165(matching.makerOrder.offerer).supportsInterface(\n                IAoriHook.afterAoriTrade.selector\n            )\n        ) {\n            bool success = IAoriHook(matching.makerOrder.offerer)\n                .afterAoriTrade(matching, hookData);\n            require(success, \"AfterAoriTrade hook failed\");\n        }\n\n        // Emit event\n        emit OrdersSettled(\n            makerHash, // makerHash\n            takerHash, // takerHash\n            getMatchingHash(matching), // matchingHash\n            matching.tradeId, // tradeId\n            matching.makerOrder.offerer, // maker\n            matching.takerOrder.offerer, // taker\n            matching.makerOrder.zone, // zone\n            matching.makerOrder.chainId // chainId\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                DEPOSIT\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Deposits tokens to the contract\n    /// @param _account The account to deposit to\n    /// @param _token The token to deposit\n    /// @param _amount The amount to deposit\n    function deposit(\n        address _account,\n        address _token,\n        uint256 _amount\n    ) external {\n        uint256 startingBalance = IERC20(_token).balanceOf(address(this));\n        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);\n\n        // Add delta of balance to the account\n        balances[_account][_token] +=\n            IERC20(_token).balanceOf(address(this)) -\n            startingBalance;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                WITHDRAW\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Withdraws tokens from the contract\n    /// @param _token The token to withdraw\n    /// @param _amount The amount to withdraw\n    function withdraw(address _token, uint256 _amount) external {\n        // Lock\n        require(!locked, \"Reentrancy guard\");\n        locked = true;\n\n        uint256 startingBalance = IERC20(_token).balanceOf(address(this));\n        IERC20(_token).safeTransfer(msg.sender, _amount);\n        balances[msg.sender][_token] -=\n            startingBalance -\n            IERC20(_token).balanceOf(address(this));\n\n        locked = false;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               FLASH LOAN\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Flash loan tokens\n    /// @param recipient The recipient\n    /// @param token The token\n    /// @param amount The amount\n    /// @param userData User data to pass to the recipient\n    /// @param receiveToken Whether to receive the token directly or fine to keep in the contract for gas efficiency\n    function flashLoan(\n        address recipient,\n        address token,\n        uint256 amount,\n        bytes memory userData,\n        bool receiveToken\n    ) external {\n        uint256 startingBalance = IERC20(token).balanceOf(address(this));\n\n        // Flash loan\n        if (receiveToken) {\n            IERC20(token).safeTransfer(recipient, amount);\n        } else {\n            balances[recipient][token] += amount;\n        }\n\n        // call the recipient's receiveFlashLoan\n        IFlashLoanReceiver(recipient).receiveFlashLoan(\n            token,\n            amount,\n            userData,\n            receiveToken\n        );\n\n        // Repay the flash loan\n        if (receiveToken) {\n            IERC20(token).safeTransferFrom(recipient, address(this), amount);\n        } else {\n            balances[recipient][token] -= amount;\n        }\n\n        // Set invariant that the contract should have at least the starting balance\n        // or more before and after the flash loan\n        require(\n            IERC20(token).balanceOf(address(this)) >= startingBalance,\n            \"Flash loan not repaid\"\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               TAKER FEE\n    //////////////////////////////////////////////////////////////*/\n\n    function setTakerFee(\n        address _newFeeRecipient,\n        uint256 _newFeeInBips\n    ) external {\n        require(\n            _newFeeRecipient != address(0),\n            \"Fee recipient cannot be zero address\"\n        );\n        require(_newFeeInBips < 100, \"Fee in bips cannot be greater than 1%\");\n\n        takerFeeRecipient = _newFeeRecipient;\n        takerFeeInBips = _newFeeInBips;\n    }\n\n    function getTakerFee()\n        external\n        view\n        returns (address feeRecipient, uint256 feeInBips)\n    {\n        feeRecipient = takerFeeRecipient;\n        feeInBips = takerFeeInBips;\n    }\n\n    function withFee(\n        uint256 amount,\n        uint256 feeInBips\n    ) public view returns (uint256) {\n        return\n            (amount * (TAKER_FEE_DENOMINATOR + feeInBips)) /\n            TAKER_FEE_DENOMINATOR;\n    }\n\n    function withoutFee(\n        uint256 amount,\n        uint256 feeInBips\n    ) public view returns (uint256) {\n        return\n            (amount * TAKER_FEE_DENOMINATOR) /\n            (TAKER_FEE_DENOMINATOR + feeInBips);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             VIEW FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function hasOrderSettled(\n        bytes32 orderHash\n    ) public view returns (bool settled) {\n        settled = BitMaps.get(orderStatus, uint256(orderHash));\n    }\n\n    function balanceOf(\n        address _account,\n        address _token\n    ) public view returns (uint256 balance) {\n        balance = balances[_account][_token];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            HELPER FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function signatureIntoComponents(\n        bytes memory signature\n    ) public pure returns (uint8 v, bytes32 r, bytes32 s) {\n        assembly {\n            r := mload(add(signature, 0x20))\n            s := mload(add(signature, 0x40))\n            v := byte(0, mload(add(signature, 0x60)))\n        }\n\n        if (v < 27) {\n            v += 27;\n        }\n    }\n\n    function getOrderHash(\n        Order memory order\n    ) public view returns (bytes32 orderHash) {\n        orderHash = keccak256(\n            abi.encodePacked(\n                order.offerer,\n                order.inputToken,\n                order.inputAmount,\n                order.outputToken,\n                order.outputAmount,\n                order.recipient,\n                // =====\n                order.zone,\n                order.chainId,\n                order.startTime,\n                order.endTime,\n                // =====\n                order.toWithdraw\n            )\n        );\n    }\n\n    function getMatchingHash(\n        MatchingDetails calldata matching\n    ) public view returns (bytes32 matchingHash) {\n        matchingHash = keccak256(\n            abi.encodePacked(\n                matching.tradeId,\n                // =====\n                matching.makerSignature,\n                matching.takerSignature,\n                // =====\n                matching.feeTag,\n                matching.feeRecipient\n            )\n        );\n    }\n}\n"},"lib/forge-std/src/interfaces/IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2;\n\n/// @dev Interface of the ERC20 standard as defined in the EIP.\n/// @dev This includes the optional name, symbol, and decimals metadata.\ninterface IERC20 {\n    /// @dev Emitted when `value` tokens are moved from one account (`from`) to another (`to`).\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /// @dev Emitted when the allowance of a `spender` for an `owner` is set, where `value`\n    /// is the new allowance.\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /// @notice Returns the amount of tokens in existence.\n    function totalSupply() external view returns (uint256);\n\n    /// @notice Returns the amount of tokens owned by `account`.\n    function balanceOf(address account) external view returns (uint256);\n\n    /// @notice Moves `amount` tokens from the caller's account to `to`.\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /// @notice Returns the remaining number of tokens that `spender` is allowed\n    /// to spend on behalf of `owner`\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /// @notice Sets `amount` as the allowance of `spender` over the caller's tokens.\n    /// @dev Be aware of front-running risks: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /// @notice Moves `amount` tokens from `from` to `to` using the allowance mechanism.\n    /// `amount` is then deducted from the caller's allowance.\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n\n    /// @notice Returns the name of the token.\n    function name() external view returns (string memory);\n\n    /// @notice Returns the symbol of the token.\n    function symbol() external view returns (string memory);\n\n    /// @notice Returns the decimals places of the token.\n    function decimals() external view returns (uint8);\n}\n"},"src/libs/SafeERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\nimport { IERC20 } from \"forge-std/interfaces/IERC20.sol\";\nimport { Address } from \"./Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC-20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev An operation with an ERC-20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}"},"src/libs/BitMaps.sol":{"content":"pragma solidity 0.8.17;\n\n/**\n * @dev Library for managing uint256 to bool mapping in a compact and efficient way, provided the keys are sequential.\n * Largely inspired by Uniswap's https://github.com/Uniswap/merkle-distributor/blob/master/contracts/MerkleDistributor.sol[merkle-distributor].\n *\n * BitMaps pack 256 booleans across each bit of a single 256-bit slot of `uint256` type.\n * Hence booleans corresponding to 256 _sequential_ indices would only consume a single slot,\n * unlike the regular `bool` which would consume an entire slot for a single value.\n *\n * This results in gas savings in two ways:\n *\n * - Setting a zero value to non-zero only once every 256 times\n * - Accessing the same warm slot for every 256 _sequential_ indices\n */\nlibrary BitMaps {\n    struct BitMap {\n        mapping(uint256 => uint256) _data;\n    }\n\n    /**\n     * @dev Returns whether the bit at `index` is set.\n     */\n    function get(BitMap storage bitmap, uint256 index) internal view returns (bool) {\n        uint256 bucket = index >> 8;\n        uint256 mask = 1 << (index & 0xff);\n        return bitmap._data[bucket] & mask != 0;\n    }\n\n    /**\n     * @dev Sets the bit at `index` to the boolean `value`.\n     */\n    function setTo(BitMap storage bitmap, uint256 index, bool value) internal {\n        if (value) {\n            set(bitmap, index);\n        } else {\n            unset(bitmap, index);\n        }\n    }\n\n    /**\n     * @dev Sets the bit at `index`.\n     */\n    function set(BitMap storage bitmap, uint256 index) internal {\n        uint256 bucket = index >> 8;\n        uint256 mask = 1 << (index & 0xff);\n        bitmap._data[bucket] |= mask;\n    }\n\n    /**\n     * @dev Unsets the bit at `index`.\n     */\n    function unset(BitMap storage bitmap, uint256 index) internal {\n        uint256 bucket = index >> 8;\n        uint256 mask = 1 << (index & 0xff);\n        bitmap._data[bucket] &= ~mask;\n    }\n}"},"src/interfaces/IAoriV2.sol":{"content":"pragma solidity 0.8.17;\n\ninterface IAoriV2 {\n    /*//////////////////////////////////////////////////////////////\n                                STRUCTS\n    //////////////////////////////////////////////////////////////*/\n\n    struct Order {\n        address offerer;\n        address inputToken;\n        uint256 inputAmount;\n        address outputToken;\n        uint256 outputAmount;\n        address recipient;\n        // =====\n        address zone;\n        uint160 chainId;\n        uint32 startTime;\n        uint32 endTime;\n        // =====\n        bool toWithdraw;\n    }\n\n    struct MatchingDetails {\n        string tradeId;\n        // =====\n        Order makerOrder;\n        Order takerOrder;\n        // =====\n        bytes makerSignature;\n        bytes takerSignature;\n        // =====\n        string feeTag;\n        address feeRecipient;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event FeeReceived(\n        address indexed feeRecipient,\n        string indexed feeTag,\n        address inputToken,\n        uint256 inputAmount,\n        address outputToken,\n        uint256 outputAmount\n    );\n\n    event OrdersSettled(\n        bytes32 indexed makerOrderHash,\n        bytes32 indexed takerOrderHash,\n        bytes32 indexed matchingHash,\n        string tradeId,\n        address maker,\n        address taker,\n        address zone,\n        uint160 chainId\n    );\n\n    /*//////////////////////////////////////////////////////////////\n                                 SETTLE\n    //////////////////////////////////////////////////////////////*/\n\n    function settleOrders(\n        MatchingDetails calldata matching,\n        bytes calldata serverSignature,\n        bytes calldata hookData\n    ) external payable;\n\n    /*//////////////////////////////////////////////////////////////\n                                DEPOSIT\n    //////////////////////////////////////////////////////////////*/\n\n    function deposit(\n        address _account,\n        address _token,\n        uint256 _amount\n    ) external;\n\n    /*//////////////////////////////////////////////////////////////\n                                WITHDRAW\n    //////////////////////////////////////////////////////////////*/\n\n    function withdraw(address _token, uint256 _amount) external;\n\n    /*//////////////////////////////////////////////////////////////\n                               FLASHLOAN\n    //////////////////////////////////////////////////////////////*/\n\n    function flashLoan(\n        address recipient,\n        address token,\n        uint256 amount,\n        bytes memory userData,\n        bool receiveToken\n    ) external;\n\n    /*//////////////////////////////////////////////////////////////\n                               TAKER FEE\n    //////////////////////////////////////////////////////////////*/\n\n    function setTakerFee(\n        address _newFeeRecipient,\n        uint256 _newFeeInBips\n    ) external;\n\n    function getTakerFee()\n        external\n        view\n        returns (address feeRecipient, uint256 feeInBips);\n\n    /*//////////////////////////////////////////////////////////////\n                             VIEW FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function hasOrderSettled(\n        bytes32 orderHash\n    ) external view returns (bool settled);\n    function balanceOf(\n        address _account,\n        address _token\n    ) external view returns (uint256 balance);\n\n    /*//////////////////////////////////////////////////////////////\n                            HELPER FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function signatureIntoComponents(\n        bytes memory signature\n    ) external pure returns (uint8 v, bytes32 r, bytes32 s);\n    function getOrderHash(\n        Order memory order\n    ) external view returns (bytes32 orderHash);\n    function getMatchingHash(\n        MatchingDetails calldata matching\n    ) external view returns (bytes32 matchingHash);\n}\n"},"src/interfaces/IAoriHook.sol":{"content":"pragma solidity 0.8.17;\n\nimport \"./IAoriV2.sol\";\n\ninterface IAoriHook {\n    function beforeAoriTrade(IAoriV2.MatchingDetails calldata matching, bytes calldata hookData) external returns (bool);\n    function afterAoriTrade(IAoriV2.MatchingDetails calldata matching, bytes calldata hookData) external returns (bool);\n}"},"src/interfaces/IERC1271.sol":{"content":"pragma solidity 0.8.17;\n\ninterface IERC1271 {\n  // bytes4(keccak256(\"isValidSignature(bytes32,bytes)\")\n  // bytes4 constant internal MAGICVALUE = 0x1626ba7e;\n\n  /**\n   * @dev Should return whether the signature provided is valid for the provided hash\n   * @param _hash      Hash of the data to be signed\n   * @param _signature Signature byte array associated with _hash\n   *\n   * MUST return the bytes4 magic value 0x1626ba7e when function passes.\n   * MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc > 0.5)\n   * MUST allow external calls\n   */ \n  function isValidSignature(\n    bytes32 _hash, \n    bytes memory _signature)\n    external\n    view \n    returns (bytes4 magicValue);\n}"},"src/interfaces/IERC165.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\npragma solidity 0.8.17;\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}"},"src/interfaces/IFlashLoanReceiver.sol":{"content":"pragma solidity 0.8.17;\n\ninterface IFlashLoanReceiver {\n    function receiveFlashLoan(\n        address token,\n        uint256 amount,\n        bytes calldata data,\n        bool receiveToken\n    ) external;\n}"},"src/libs/SignatureChecker.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/SignatureChecker.sol)\n\npragma solidity 0.8.17;\n\nimport {ECDSA} from \"./ECDSA.sol\";\nimport {IERC1271} from \"../interfaces/IERC1271.sol\";\n\n/**\n * @dev Signature verification helper that can be used instead of `ECDSA.recover` to seamlessly support both ECDSA\n * signatures from externally owned accounts (EOAs) as well as ERC-1271 signatures from smart contract wallets like\n * Argent and Safe Wallet (previously Gnosis Safe).\n */\nlibrary SignatureChecker {\n    /**\n     * @dev Checks if a signature is valid for a given signer and data hash. If the signer is a smart contract, the\n     * signature is validated against that smart contract using ERC-1271, otherwise it's validated using `ECDSA.recover`.\n     *\n     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus\n     * change through time. It could return true at block N and false at block N+1 (or the opposite).\n     */\n    function isValidSignatureNow(address signer, bytes32 hash, bytes memory signature) internal view returns (bool) {\n        (address recovered, ECDSA.RecoverError error, ) = ECDSA.tryRecover(hash, signature);\n        return\n            (error == ECDSA.RecoverError.NoError && recovered == signer) ||\n            isValidERC1271SignatureNow(signer, hash, signature);\n    }\n\n    /**\n     * @dev Checks if a signature is valid for a given signer and data hash. The signature is validated\n     * against the signer smart contract using ERC-1271.\n     *\n     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus\n     * change through time. It could return true at block N and false at block N+1 (or the opposite).\n     */\n    function isValidERC1271SignatureNow(\n        address signer,\n        bytes32 hash,\n        bytes memory signature\n    ) internal view returns (bool) {\n        (bool success, bytes memory result) = signer.staticcall(\n            abi.encodeCall(IERC1271.isValidSignature, (hash, signature))\n        );\n        return (success &&\n            result.length >= 32 &&\n            abi.decode(result, (bytes32)) == bytes32(IERC1271.isValidSignature.selector));\n    }\n}"},"src/libs/Address.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}"},"src/libs/ECDSA.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity 0.8.17;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n\n    /**\n     * @dev The signature derives the `address(0)`.\n     */\n    error ECDSAInvalidSignature();\n\n    /**\n     * @dev The signature has an invalid length.\n     */\n    error ECDSAInvalidSignatureLength(uint256 length);\n\n    /**\n     * @dev The signature has an S value that is in the upper half order.\n     */\n    error ECDSAInvalidSignatureS(bytes32 s);\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with `signature` or an error. This will not\n     * return address(0) without also returning an error description. Errors are documented using an enum (error type)\n     * and a bytes32 providing additional information about the error.\n     *\n     * If no error is returned, then the address can be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[ERC-2098 short signatures]\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\n        unchecked {\n            bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            // We do not check for an overflow here since the shift operation results in 0 or 1.\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError, bytes32) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n  2 + 1, and for v in (302): v  {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Optionally reverts with the corresponding custom error according to the `error` argument provided.\n     */\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}"}},"settings":{"remappings":["ds-test/=lib/ds-test/src/","solmate/=lib/solmate/src/","forge-std/=lib/forge-std/src/","create3-factory/=lib/create3-factory/"],"optimizer":{"enabled":true,"runs":1000000},"metadata":{"useLiteralContent":false,"bytecodeHash":"ipfs"},"outputSelection":{"*":{"*":["abi","evm.bytecode","evm.deployedBytecode","evm.methodIdentifiers","metadata"]}},"evmVersion":"london","viaIR":true,"libraries":{}}}
